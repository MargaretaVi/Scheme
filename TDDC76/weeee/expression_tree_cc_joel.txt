/*
 * Laboration 3 Expression_Tree.cc
 * Gustav Nordh och Joel Martinsson
 * Gusno089         Joema115
 *
 * Funktionsdefintioner för klassen Expression_Tree och dess subklasser.
 */
#include "Expression_Tree.h"
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <typeinfo>
#include <cmath>

using namespace std;


// -- BINARY OPERATOR --

// Konstruktor
Binary_Operator::Binary_Operator(Expression_Tree* LN, Expression_Tree* RN, string opr)
{
  if(opr == "=")
    {
      if(! isalpha(LN->str()[0]))
	{
	  throw Expression_Tree_Error("Går endast tilldela en variabel\n");
	}
    }
  Left_node = LN;
  Right_node = RN;    
  str_opr = opr; 
  
}

// Destruktor
Binary_Operator::~Binary_Operator()
{
  delete Left_node;
  delete Right_node;
}

// Funktioner

// get_postfix() - Returnerar utrycket i postfixformat.
string Binary_Operator::get_postfix()  const
{
  return Left_node->get_postfix() +" "+  Right_node->get_postfix() +" "+ str() ;
}

// get_infix() - Returnerar utrycket i infixformat.
string Binary_Operator::get_infix() const
{
  if(str()=="=")
    {
      return "(" + Left_node->get_infix() +" "+ str() + " " + str_clean(Right_node->get_infix())+")";
    }
  else
    {
      return "(" + Left_node->get_infix()+" "+ str() +" "+ Right_node->get_infix()+")";
    }
}

// str() - Returnerar operatorn som en sträng.
string Binary_Operator::str() const
{
  return str_opr;
}

// print(os,int) - Skriver ut ett träd på "os" och djupet int.
void Binary_Operator::print(ostream& os,int depth) const
{
  Right_node->print(os,depth+2);
  os << setw(depth + 1) <<"/"<< endl
     << setw(depth) << str() << endl
     << setw(depth + 1) << "\\" <<endl;
  Left_node->print(os, depth+2);
}

// Rensar bort paranteser.
string Binary_Operator::str_clean(string str) const
{
  if(isdigit(str[0]))
    {
      return str;
    }
  else
    {
	str.erase(str.begin());
	str.erase(str.end()-1);
	return str;
    }
}
  
// -- OPERAND --

// Konstruktor
// Operand::Operand() 
// {}

// Funktioner 

// get_postfix() - Returnerar värdet som sträng.
string Operand::get_postfix() const
{
  return this->str();
}

// get_infix() - Returnerar värdet som sträng.
string Operand::get_infix() const
{
  return this->str();
}

// print(os,int) skriver ut värdet på djupet int.
void Operand::print(ostream& os,int depth) const
{
  os <<setw(depth)<<this->str()<<endl; 
}

// - ASSIGN -

// Konstruktor
Assign::Assign(Expression_Tree* LN, Expression_Tree* RN)
  : Binary_Operator(LN,RN,"=")
{}

// Funktioner

// evaluate() - Räknar ut värder i högernod och sätter vänsternod till det, returnerar dess värde.
double Assign::evaluate() const
{
  Variable* pek = dynamic_cast<Variable*>(Left_node);
  pek->set_value(Right_node->evaluate()); 
  return pek->get_value();
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Assign::clone()
{
  Expression_Tree* temp_LN;
  Expression_Tree* temp_RN;
  try
    {
      temp_LN =Left_node->clone();
      temp_RN =Right_node->clone();
      Expression_Tree* op = new Assign(temp_LN,temp_RN);
      return op;
    }
  catch(...)
    {
      delete temp_LN;
      delete temp_RN;
      throw;
    }
}

// - PLUS -
  
// Konstruktor
Plus::Plus(Expression_Tree* LN, Expression_Tree* RN)
  : Binary_Operator(LN,RN,"+")
{}

// Funktioner

// evalute() - Addera värderna i höger- och vänsternod.
double Plus::evaluate() const
{
  double LN = Left_node->evaluate();
  double RN = Right_node->evaluate();
  return (LN + RN); 
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Plus::clone()
{
  Expression_Tree* temp_LN;
  Expression_Tree* temp_RN;
  try
    {
      temp_LN = Left_node->clone();
      temp_RN = Right_node->clone();
      Expression_Tree* op = new Plus(temp_LN,temp_RN);
      return op;
    }
  catch(...)
    {
      delete temp_LN;
      delete temp_RN;
      throw;
    }
}

// - MINUS -

// Konstruktor
Minus::Minus(Expression_Tree* LN, Expression_Tree* RN)
  : Binary_Operator(LN,RN,"-")
{}

// Funktioner

// evalute() - Subbtraherar värderna i höger- och vänsternod.
double Minus::evaluate() const
{
  double LN = Left_node->evaluate();
  double RN = Right_node->evaluate();
  return (LN - RN); 
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Minus::clone()
{
  Expression_Tree* temp_LN;
  Expression_Tree* temp_RN;
  try
    {
      temp_LN =Left_node->clone();
      temp_RN =Right_node->clone();
      Expression_Tree* op = new Minus(temp_LN,temp_RN);
      return op;
    }
  catch(...)
    {
      delete temp_LN;
      delete temp_RN;
      throw;
    }
}

// - TIMES -

// Konstruktor
Times::Times(Expression_Tree* LN, Expression_Tree* RN)
  : Binary_Operator(LN,RN,"*")
{}

// Funktioner
// evalute() - Multiplicerar värderna i höger- och vänsternod.
double Times::evaluate() const
{
  double LN = Left_node->evaluate();
  double RN = Right_node->evaluate();
  return (LN * RN); 
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Times::clone()
{
  Expression_Tree* temp_LN;
  Expression_Tree* temp_RN;
  try
    {
      temp_LN =Left_node->clone();
      temp_RN =Right_node->clone();
      Expression_Tree* op = new Times(temp_LN,temp_RN);
      return op;
    }
  catch(...)
    {
      delete temp_LN;
      delete temp_RN;
      throw;
    }
}

// - DIVIDE -

// Konstruktor

Divide::Divide(Expression_Tree* LN, Expression_Tree* RN)
  : Binary_Operator(LN,RN,"/")
{}

// Funktioner

// evaluate() - Dividerar värdet i högernod med värdet i vänsternod.
double Divide::evaluate() const
{
  double LN = Left_node->evaluate();
  double RN = Right_node->evaluate();
  if(RN == 0)
    {
      throw Expression_Tree_Error("AJABAJA man får inte dela med 0\n");
    }
  
  return (LN / RN); 
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Divide::clone()
{
  Expression_Tree* temp_LN;
  Expression_Tree* temp_RN;
  try
    {
      temp_LN =Left_node->clone();
      temp_RN =Right_node->clone();
      Expression_Tree* op = new Divide(temp_LN,temp_RN);
      return op;
    }
  catch(...)
    {
      delete temp_LN;
      delete temp_RN;
      throw;
    }
}


// - POWER -

// Konstruktor
// evalute() - "Höjer upp" värdet i högernod med värdet i vänsternod.
Power::Power(Expression_Tree* LN, Expression_Tree* RN)
  : Binary_Operator(LN,RN,"^")
{}

// Funktioner
double Power::evaluate()  const
{
  double LN = Left_node->evaluate();
  double RN = Right_node->evaluate();
  if(LN<0 && fmod(RN,1)!=0)
    {
      throw  Expression_Tree_Error("Svaret blir komplext");
    }
  return pow(LN,RN); 
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Power::clone()
{
  Expression_Tree* temp_LN;
  Expression_Tree* temp_RN;
  try
    {
      temp_LN =Left_node->clone();
      temp_RN =Right_node->clone();
      Expression_Tree* op = new Power(temp_LN,temp_RN);
      return op;
    }
  catch(...)
    {
      delete temp_LN;
      delete temp_RN;
      throw;
    }
}

// - INTEGER -

// Konstruktorer
Integer::Integer(int nr)
  : Operand()
{
value = nr;
}

// Funktioner

// evaluate() - Returnerar värdet.
double Integer::evaluate()  const
{
  return value;
}

// str() - Returnerar värdet som sträng.
string Integer::str() const
{
  stringstream ss;
  ss << value;
  return ss.str(); 
}
// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Integer::clone()
{
  Expression_Tree* op = new Integer(value);
  return op;
}

// - REAL-

// Konstruktorer
Real::Real(double nr)
  : Operand()
{
	value = nr;
}

// Funktioner

// evaluate() - Returnerar värdet.
double Real::evaluate() const
{
  return value;
}

// str() - Returnerar värdet som sträng.
string Real::str() const
{
  stringstream ss;
  ss << value;
  return ss.str(); 
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Real::clone()
{
  Expression_Tree* op = new Real(value);
  return op;
}

// - VARIABLE -

// Konstruktorer
Variable::Variable(string tecken,Variable_Table*& var_table,double init_value)
  : Operand()
{
  if(tecken.size() > 1)
    {
      throw Expression_Tree_Error("En variabel får endast bestå av ett tecken\n");
    }
  value = init_value;
  variable_name = tecken;
  variable_table = var_table;
}

// Funktioner 

// evaluate() - Returnerar värdet på variablen.
double Variable::evaluate() const
{
  return variable_table->get_value(variable_name);
}

// str() - Returnerar variablens symbol som sträng.
string Variable::str() const
{
  return variable_name;
}

// clone() - Returnerar en kopia av sig själv.
Expression_Tree* Variable::clone()
{
  Expression_Tree* op = new Variable(variable_name,variable_table,value);
  return op;
}

// set_value(value) - Sätter om värdet i variable_name i variabellistan.
void Variable::set_value(const double new_value)
{
  if(variable_table->find(variable_name))
    {
      variable_table->set_value(variable_name,new_value);
    }
  else
    {
      variable_table->insert(variable_name,new_value);
    }
}

// get_value() - Hämtar värdet i variable_name från variabellistan.
double Variable::get_value() const
{
  return variable_table->get_value(variable_name);
}
