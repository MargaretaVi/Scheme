 /*
 * Laboration 3 Variable_Table.h
 * Gustav Nordh och Joel Martinsson
 * Gusno089         Joema115
 *
 * Funktionsdeklarationer för klassen Variable_Table 
 */

#include "Expression.h"
#include "Expression_Tree.h"
#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <iterator>
#include <map>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <string>
#include <vector>
using namespace std;

// -- Konstruktorer --
Expression::Expression(Expression_Tree* objkt)
{
  if(objkt == nullptr)
    {
      Node = nullptr;
    }
  else
    {
      Node = objkt;
    }
}

Expression::Expression(const Expression& objkt)
{
  if(objkt.Node == nullptr)
    {
      Node = nullptr;
    }
  else
    {
      Node = objkt.Node->clone(); 
    }
}

// Flyttsemantik
Expression::Expression(Expression&& objkt)
{
  Node = objkt.Node;
  objkt.Node = nullptr;
}

// Operatorer
void Expression::operator=(const Expression& objkt)
{
  if(objkt.Node == nullptr)
    {
      delete Node;
      Node = nullptr;
    }
  else if(&objkt.Node != &Node)
    {
      delete Node;
      Node = objkt.Node->clone(); 
    }
}

// Flyttsemantik 
void  Expression::operator=(Expression&& objkt)
{
  delete Node;
  Node = objkt.Node;
  objkt.Node = nullptr;
}

// Destruktor
Expression::~Expression()
{
  delete Node;
}

// -- Funktioner --

// evaluate() - Räknar ut hela uttrycket.
double Expression::evaluate() const
{
  if(Node == nullptr)
    {
      throw Expression_Error("Tomt utryck - evaluate\n");
    }
  else
    {
    return Node->evaluate();
    }
}

// empty() - Returnerar True om uttrycket är tomt.
bool Expression::empty() const
{
  return (Node == nullptr);
}


//  print_tree() - Skriver ut uttrycket i trädform. 
void Expression::print_tree(std::ostream& os) const
{
  if(Node == nullptr)
    {
     throw Expression_Error("Inget träd att rita ut.");
    }
  Node->print(os);
}

// swap(other) -- Byter innehåll med ett annat expression.
void Expression::swap(Expression& source)
{
  Expression_Tree* Temp_Node = Node;
  
  Node = source.Node;
  source.Node = Temp_Node;  
}

// clear() - Rensar uttrycket och nollställer pekaren.
void Expression::clear()
{
  delete Node;
  Node = nullptr;
}

// get_postfix() - Returnerar uttrycket i postfixformat.
std::string Expression::get_postfix() const
{ 
  if(Node == nullptr)
    {
      throw Expression_Error("Tomt utryck - get_postfix\n");
    }
  else
    {
      return Node->get_postfix();
    }
}

// get_infix() - Returnerar uttrycket i infixformat, med paranteser.
std::string Expression::get_infix()
{ 
  if(Node == nullptr)
    {
      throw Expression_Error("Tomt utryck - get_infix\n");
    }
  else
    {
      return str_clean(Node->get_infix());
    }
}

// str_clean(string) - Rensar bort paranteser i infix string.
string Expression::str_clean(string str)
{
  str.erase(str.begin());
  str.erase(str.end()-1);
  return str;
}
// Slut Klass


// clean(stack) - rensar bort dynamiska objekt i stacken. Används om det blir något fel i postfix-konstruktionen.
void clean(stack<Expression_Tree*>& tree)
{
  while (! tree.empty())
    {
      delete tree.top();
      tree.pop();
    }
}

// swap(x, y) - Byter innehåll mellan 2 expressions som matas in. 
void swap(Expression& target1, Expression& target2)
{
  target1.swap(target2);
}

// make_expression() definieras efter namnrymden nedan.

// Namnrymden nedan innehåller intern kod för infix-till-postfix-omvandling
// och generering av uttrycksträd. Används endast i denna fil.



namespace
{
   using std::vector;
   using std::map;
   using std::make_pair;
   using std::string;

   // Underlag för att skapa prioritetstabellerna, mm. Högre värde inom
   // input_prio respektive stack_prio anger inbördes prioritetsordning.
   // Högre värde i input_prio jämfört med motsvarande position i stack_prio
   // innebär högerassociativitet, det motsatta vänsterassociativitet.
   // (Flerteckenoperatorer kan också hanteras med denna representation)
   const char* ops[]      = { "^", "*", "/", "+", "-", "=" };
   const int input_prio[] = {  8,   5,   5,   3,   3,   2  };
   const int stack_prio[] = {  7,   6,   6,   4,   4,   1  };
   const int n_ops = sizeof ops / sizeof(char*);

   // Tillåtna operatorer. Används av make_postfix() och make_expression_tree().
   const vector<string> operators(ops, ops + n_ops);

   // Teckenuppsättningar för operander. Används av make_expression_tree().
   const string letters("abcdefghijklmnopqrstuvwxyz");
   const string digits("0123456789");
   const string integer_chars(digits);
   const string real_chars(digits + '.');
   const string variable_chars(letters);
   const string operand_chars(letters + digits + '.');

   // Hjälpfunktioner för att kategorisera lexikala element.
   bool is_operator(char token)
   {
      return find(operators.begin(), operators.end(), string(1, token)) != operators.end();
   }

   bool is_operator(const string& token)
   {
      return find(operators.begin(), operators.end(), token) != operators.end();
   }

   bool is_operand(const string& token)
   {
      return token.find_first_not_of(operand_chars) == string::npos;
   }

   bool is_integer(const string& token)
   {
      return token.find_first_not_of(integer_chars) == string::npos;
   }

   bool is_real(const string& token)
   {
      return token.find_first_not_of(real_chars) == string::npos;
   }

   bool is_identifier(const string& token)
   {
      return token.find_first_not_of(letters) == string::npos;
   }

   // Prioritetstabeller. Används av make_postfix().
   typedef map<string, int> priority_table;

   // Funktion för att initiera en prioritetstabell, givet de tillåtna operatorerna,
   // deras prioritieter (inkommandeprioritet eller stackprioritet, beroende på vilken
   // tabell som ska skapas) och antalet operatorer.
   priority_table init_priority_table(const char* ops[], const int* prio, const int n_ops)
   {
      priority_table pm;

      for (int i = 0; i < n_ops; ++i)
      {
	 pm.insert(make_pair(string(ops[i]), prio[i]));
      }

      return pm;
   }

   // Prioritetstabellerna, en för inkommandeprioritet och en för stackprioritet.
   const priority_table input_priority = init_priority_table(ops, input_prio, n_ops);
   const priority_table stack_priority = init_priority_table(ops, stack_prio, n_ops);

  // format_infix() tar en sträng med ett infixuttryck och formaterar den så att
  // det finns ett mellanrum mellan varje symbol. Används av make_postfix(), där
  // denna formatering underlättar parsningen.

   std::string format_infix(const std::string& infix)
   {
      string::const_iterator bos = infix.begin();
      string::const_iterator eos = infix.end();
      string                 formated;

      for (string::const_iterator it = bos; it != eos; ++it)
      {
	 if (is_operator(*it) || *it == '(' || *it == ')')
	 {
	    // Se till att det är ett mellanrum före en operator eller parentes
	    if (it != bos && *(it - 1) != ' ' && *(formated.end() - 1) != ' ')
	       formated.append(1, ' ');
	    formated.append(1, *it);
	    // Se till att det är ett mellanrum efter en operator eller parentes
	    if ((it + 1) != eos && *(it + 1) != ' ')
	       formated.append(1, ' ');
	 }
	 else
	 {
	    if (*it != ' ')
	       formated.append(1, *it);
	    else if (it != bos && *(it - 1) != ' ')
	       formated.append(1, *it);
	 }
      }
      return formated;
   }

   // make_postfix() tar en infixsträng och returnerar motsvarande postfixsträng.
  
   std::string make_postfix(const std::string& infix)
   {
      using std::stack;
      using std::string;
      using std::istringstream;
      using std::find;

      stack<string> operator_stack;
      string        token;
      string        previous_token = "";
      bool          last_was_operand = false;
      int           paren_count = 0;

      istringstream is(format_infix(infix));
      string        postfix;

      while (is >> token)
      {
   	if (is_operator(token))
   	 {
   	    if (! last_was_operand || postfix.empty() || previous_token == "(")
   	    {
   	      throw Expression_Error("operator där operand förväntades\n");
   	    }

   	    // Järnvägsalgoritmen
   	    while (! operator_stack.empty() &&
   		   input_priority.find(token)->second <=
   		   stack_priority.find(operator_stack.top())->second)
   	    {
   	       postfix += operator_stack.top() + ' ';
   	       operator_stack.pop();
   	    }
   	    operator_stack.push(token);
   	    last_was_operand = false;
   	 }
   	 else if (token == "(")
   	 {
	   operator_stack.push(token);	   
	   ++paren_count;
   	 }
   	 else if (token == ")")
   	 {
   	    if (paren_count == 0)
   	    {
   	      throw Expression_Error("vänsterparentes saknas\n");
   	    }

   	    if (previous_token == "(" && ! postfix.empty())
   	    {
   	      throw Expression_Error("tom parentes\n");
   	    }
	    
   	    while(! operator_stack.empty() && operator_stack.top() != "(")
   	    {
	      postfix += operator_stack.top() + ' ';
	      operator_stack.pop();
   	    }
	    	 
   	    if (operator_stack.empty())
   	      {
		throw Expression_Error("högerparentes saknar matchande vänsterparentes\n");
   	      }
	    
   	    // Det finns en vänsterparentes på stacken
   	    operator_stack.pop();
   	    --paren_count;
	    
   	 }
   	 else if (is_operand(token))
   	 {
   	    if (last_was_operand || previous_token == ")")
   	    {
   	      throw Expression_Error("operand där operator förväntades\n");
   	    }

   	    postfix += token + ' ';
   	    last_was_operand = true;
   	 }
   	 else
   	 {
   	   throw Expression_Error("otillåten symbol\n");
   	 }

   	 previous_token = token;
      }

      if (postfix == "")
      {
   	throw Expression_Error("tomt infixuttryck!\n");
      }

      if ((! last_was_operand) && (! postfix.empty()))
      {
   	throw Expression_Error("operator avslutar\n");
      }

      if (paren_count > 0)
      {
   	throw Expression_Error("högerparentes saknas\n");
      }

      while (! operator_stack.empty())
      {
   	 postfix += operator_stack.top() + ' ';
   	 operator_stack.pop();
      }

      if (! postfix.empty())
      {
   	 postfix.erase(postfix.size() - 1);
      }

      return postfix;
   }


   // make_expression_tree() tar en postfixsträng och returnerar ett motsvarande 
   // länkat träd av Expression_Tree-noder. Tänk på minnesläckage...

  /* Lätt modifierad för att lägga in Variable_Table i variable konstruktorn, 
   * kontrollera om vi gör flera tilldelningar i samma uttryck samt destruera objekt som 
   * skapas, om vi får något undantag under tiden vi kör.
   */

  Expression_Tree* make_expression_tree(const std::string& postfix, Variable_Table*& var_table)
   {
      using std::stack;
      using std::string;
      using std::istringstream;

      stack<Expression_Tree*> tree_stack;
      string                  token;
      istringstream           ps(postfix);
      bool multiple_assign = false;
      Expression_Tree* lhs;
      Expression_Tree* rhs;
      try
	{
	  while (ps >> token)
	    {
	      if (is_operator(token))
		{
		  if (tree_stack.empty()) 
		    {
		      throw Expression_Error("felaktig postfix\n");
		    }
		  rhs = tree_stack.top();
		  tree_stack.pop();

		  if (tree_stack.empty()) 
		    {
		      throw Expression_Error("felaktig postfix\n");
		    }
		  lhs = tree_stack.top();
		  tree_stack.pop();

		  if (token == "^")
		    {
		      tree_stack.push(new Power(lhs, rhs));
		    }
		  else if (token == "*")
		    {
		      tree_stack.push(new Times(lhs, rhs));
		    }
		  else if (token == "/")
		    {
		      tree_stack.push(new Divide(lhs, rhs));
		    }
		  else if (token == "+")
		    {
		      tree_stack.push(new Plus(lhs, rhs));
		    }
		  else if (token == "-")
		    {
		      tree_stack.push(new Minus(lhs, rhs));
		    }
		  else if (token == "=")
		    {
		      if(multiple_assign)
			{
			  throw Expression_Error("Kan inte använda flera tilldelninar i samma uttryck\n");
			}
		      else
			{
			  tree_stack.push(new Assign(lhs, rhs));
			  multiple_assign = true;
			}
		    }
		}
	      else if (is_integer(token))
		{
		  tree_stack.push(new Integer(atoi(token.c_str())));
		}
	      else if (is_real(token))
		{
		  tree_stack.push(new Real(atof(token.c_str())));
		}
	      else if (is_identifier(token))
		{
		  tree_stack.push(new Variable(token,var_table));
		}
	      else
		{
		  throw Expression_Error("felaktig postfix\n");
		}
	    }
	  // Det ska bara finnas ett träd på stacken om postfixen är korrekt.

	  if (tree_stack.empty())
	    {
	      throw Expression_Error("ingen postfix given\n");
	    }

	  if (tree_stack.size() > 1)
	    {
	      while (! tree_stack.empty())
		{
		  delete tree_stack.top();
		  tree_stack.pop();
		}
	      throw Expression_Error("felaktig postfix\n");
	    }
	  
	  // Returnera trädet.
	  return tree_stack.top();
      
	}
      catch(...)
	{
	  delete lhs;
	  delete rhs;
	  clean(tree_stack);
	  throw;
	}
   }
} // namespace


// make_expression(infix,var_table) - Skapar ett utryck med ett uttryck i infix
// format och en variabellista. 
 
Expression make_expression(const string& infix,Variable_Table*& var_table)
{
  return Expression(make_expression_tree(make_postfix(infix),var_table));
}
